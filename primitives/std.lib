primitive std_reg[p_width](in: p_width, write_en: 1, clk: 1) -> (out: p_width, done: 1) {
  verilog {
    module std_reg
      #(parameter width = 32,
        parameter reset_val = 0)
       (input wire [width-1:0] in,
        input wire write_en,
        input wire clk,
        // output
        output logic [width - 1:0] out,
        output logic done);

      always_ff @(posedge clk) begin
        if (write_en) begin
          out <= in;
          done <= 1'd1;
        end else
          done <= 1'd0;
      end
    endmodule
  }
}

primitive std_iterator[p_width, p_start, p_stop, p_incr]
    (valid: 1, clk: 1)
    -> (out: p_width, stop: 1, out_read_out: 1, ready: 1)
  {}

primitive std_const[p_width, p_value](valid: 1) -> (out: p_width, out_read_out: 1, ready: 1) {
  verilog {
    module std_const
      #(parameter width = 32,
        parameter value = 0)
       (input logic                valid,
        output logic               ready,
        output logic [width - 1:0] out,
        output logic               out_read_out);
      assign out = value;
      assign ready = valid;
      assign out_read_out = valid;
    endmodule
  }
}

primitive std_add[p_width](left: p_width, right: p_width) -> (out: p_width) {
  verilog {
    module std_add
      #(parameter width = 32)
      (input  logic [width-1:0] left,
        input  logic [width-1:0] right,
        output logic [width-1:0] out);
      assign out = left + right;
    endmodule
  }
}

primitive std_sub[p_width](left: p_width, right: p_width) -> (out: p_width) {
  verilog {
    module std_sub
      #(parameter width = 32)
      (input  logic [width-1:0] left,
        input  logic [width-1:0] right,
        output logic [width-1:0] out);
      assign out = left - right;
    endmodule
  }
}

primitive std_mult[p_width](left: p_width, right: p_width) -> (out: p_width) {
  verilog {
    module std_mult
      #(parameter width = 32)
      (input logic  [width-1:0] left,
        input logic  [width-1:0] right,
        output logic [width-1:0] out);
      assign out = left * right;
    endmodule
  }
}

primitive std_div[p_width](left: p_width, right: p_width) -> (out: p_width) {
  verilog {
    module std_div
      #(parameter width = 32)
      (input logic  [width-1:0] left,
        input logic  [width-1:0] right,
        output logic [width-1:0] out);
      assign out = left / right;
    endmodule
  }
}

primitive std_not[p_width](in: p_width) -> (out: p_width) {
  verilog {
    module std_not
      #(parameter width = 32)
      (input logic [width-1:0] in,
        output logic [width-1:0] out);
      assign out = ~in;
    endmodule
  }
}

primitive std_and[p_width](left: p_width, right: p_width) -> (out: p_width) {
  verilog {
    module std_and
      #(parameter width = 32)
      (input logic  [width-1:0] left,
        input logic  [width-1:0] right,
        output logic [width-1:0] out);
      assign out = left & right;
    endmodule
  }
}

primitive std_or[p_width](left: p_width, right: p_width) -> (out: p_width) {
  verilog {
    module std_or
      #(parameter width = 32)
      (input logic  [width-1:0] left,
        input logic  [width-1:0] right,
        output logic [width-1:0] out);
      assign out = left | right;
    endmodule
  }
}

primitive std_gt[p_width](left: p_width, right: p_width) -> (out: 1) {
  verilog {
    module std_gt
      #(parameter width = 32)
      (input logic [width-1:0] left,
        input logic [width-1:0] right,
        output logic            out);
      assign out = left > right;
    endmodule
  }
}

primitive std_lt[p_width](left: p_width, right: p_width) -> (out: 1) {
  verilog {
    module std_lt
      #(parameter width = 32)
      (input logic [width-1:0] left,
        input logic [width-1:0] right,
        output logic            out);
      assign out = left < right;
    endmodule
  }
}

primitive std_eq[p_width](left: p_width, right: p_width) -> (out: 1) {
  verilog {
    module std_eq
      #(parameter width = 32)
      (input logic [width-1:0] left,
        input logic [width-1:0] right,
        output logic            out);
      assign out = left == right;
    endmodule
  }
}

primitive std_neq[p_width](left: p_width, right: p_width) -> (out: 1) {
  verilog {
    module std_neq
      #(parameter width = 32)
      (input logic [width-1:0] left,
        input logic [width-1:0] right,
        output logic            out);
      assign out = left != right;
    endmodule
  }
}

primitive std_ge[p_width](left: p_width, right: p_width) -> (out: p_width) {
  verilog {
    module std_ge
      #(parameter width = 32)
      (input logic [width-1:0] left,
        input logic [width-1:0] right,
        output logic            out);
      assign out = left >= right;
    endmodule
  }
}

primitive std_le[p_width](left: p_width, right: p_width) -> (out: 1) {
  verilog {
    module std_le
      #(parameter width = 32)
      (input logic [width-1:0] left,
       input logic [width-1:0] right,
       output logic            out);
      assign out = left <= right;
    endmodule
  }
}

primitive std_start_fsm(valid: 1, reset: 1, clk: 1) -> (out: 1) {
  verilog {
    module std_start_fsm
     (input logic  valid,
      input logic  reset,
      input logic  clk,
      // outputs
      output logic out);

      logic        state;
      always_ff @(posedge clk) begin
      if (reset) begin
        out <= 1'b0;
        state <= 1'b0;
      end else
        case ({valid, state})
          2'b00: out <= 1'b0;
          2'b10: begin
            state <= 1'b1;
            out <= 1'b1;
          end
          2'b01: out <= 1'b0;
          2'b11: out <= 1'b0;
        endcase
      end
    endmodule
  }
}

primitive std_fsm_state(in: 1, reset: 1, clk: 1) -> (out: 1) {
 verilog {
    module std_fsm_state
      (input logic  in,
       input logic  reset,
       input logic  clk,
       // outputs
       output logic out);

      logic        state;

      always_ff @(posedge clk) begin
        if (reset) state <= 1'b0;
        else begin
          state <= in;
        end
      end

      always_comb
        out = state;
    endmodule
  }
}
