#lang racket/base

(require futil)

(define/module main () ()
  ([gad2 = new comp/id]
   [gad1 = new comp/id]
   [mult0 = new comp/mult]
   [v0 = new comp/reg]
   [i0 = new comp/iterator]
   [dot-we0 = new comp/id]
   [dot-we1 = new comp/id]
   [comb-add0 = new comp/add]
   [gad0 = new comp/id]
   [dot = new comp/memory1d]
   [B = new comp/memory1d]
   [A = new comp/memory1d]
   [const A-init #f : 32 -> A @ data-in]
   [const B-init #f : 32 -> B @ data-in]
   [const dot-init #f : 32 -> dot @ data-in]
   [const const0 0 : 32 -> gad0 @ in]
   [gad0 @ out -> dot @ addr]
   [dot-we0 @ out -> dot @ data-in]
   [const const1 0.0 : 32 -> dot-we0 @ in]
   [const i0-start 0 : 32 -> i0 @ start]
   [const i0-incr 1 : 32 -> i0 @ incr]
   [const i0-end 8 : 32 -> i0 @ end]
   [const i0-en 1 : 32 -> i0 @ en]
   [mult0 @ out -> v0 @ in]
   [A @ out -> mult0 @ left]
   [B @ out -> mult0 @ right]
   [i0 @ out -> gad1 @ in]
   [gad1 @ out -> A @ addr]
   [i0 @ out -> gad2 @ in]
   [gad2 @ out -> B @ addr]
   [v0 @ out -> comb-add0 @ left]
   [dot @ out -> comb-add0 @ right]
   [comb-add0 @ out -> dot-we1 @ in]
   [dot-we1 @ out -> dot @ data-in]
   )
  [(!! dot gad0 dot-we0 const0 const1)]
  [(!! i0-en i0-start i0-incr i0-end i0)]
  [(while (i0 @ stop)
     (;; [(!! A B i0 gad1 gad2)]
      [(!! v0 mult0 A B i0 gad1 gad2)]
      [(!! dot comb-add0 dot-we1 v0 const0 gad0)]
      ;; [(!! dot comb-add0 dot-we1 v0 const0 gad0)]
      [(!! i0 i0-en)]))]
  [(mem-print dot)])

;; (require futil/visualizer)
;; (plot-component (main))
(parse-cmdline (main) "../dot-product.json")

;; (require futil/component)
;; (require racket/sequence)
;; (plot-component (comp/iterator))

;; (filter-map
;;  (lambda (x) (if (equal? 'val-reg (caar x))
;;                  (if (blocked? (hash-ref state (car x)))
;;                      #f
;;                      (caadr x))
;;                  #f))
;;  (sequence->list (in-neighbors (component-graph (comp/iterator)) '(val-reg . out))))

;; (define state (make-immutable-hash `(((iter . out) . ,(blocked #f 'cat)) ((iter . stop) . 10))))
;; (require threading)
;; (~>
;;  state
;;  hash->list
;;  (filter-not (lambda (x) (println (blocked? (cdr x))) (blocked? (cdr x)))
;;              _)
;;  (map (lambda (x) (in-neighbors (component-graph (comp/iterator)) (car x))) _)
;;  ;; (component-graph (comp/iter))
;;     ;; ()
;;     )

;; (require futil/component)
;; (get-edges (component-graph (comp/iterator)))
;; (has-vertex? (component-graph (comp/iterator)) '(ins-and . out))
